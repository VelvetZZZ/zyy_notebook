```python
print("这是数字输出格式{:5d}".format(123)) 
```
1. "这是数字输出格式{:5d}" 是一个包含格式化占位符的字符串：{:5d} 是一个格式化指令，其中：

: 表示开始格式规范

5 指定总宽度为5个字符

d 表示将值格式化为十进制整数

2. .format() 方法
.format(123) 将数字123插入到字符串的占位符中：
数字123被格式化为整数
由于指定了宽度为5，而123只有3位数字，所以会在左侧添加空格以达到5字符宽度


# Python 切片（slice）语法的关键点。

1. 完整的切片语法
Python 切片最完整的形式是 [start:stop:step]，它由两个冒号分隔开三个部分：

start: 起始索引（包含该位置）。

stop: 结束索引（不包含该位置）。

step: 步长（每次跳跃的距离）。

2. 语法的简写与默认值
为了方便使用，Python 允许你省略其中的任何部分，此时会使用默认值：

如果省略 start，它默认为 0（从头开始）。

如果省略 stop，它默认为列表的末尾。

如果省略 step，它默认为 1（一个挨一个地取，不跳跃）。

举几个例子来对比：

切片语法	start	  stop	     step	          解释
lst[0:100]	0	     100	    1（默认） 从索引0到100，步长为1。只用了1个冒号。 
lst[:5]	    0（默认）  5	     1(默认)	    从头到索引5之前。只用了1个冒号。
lst[2:]	    2	    末尾(默认)	  1(默认)	     从索引2到末尾。只用了1个冒号。
lst[::2]	0 (默认)   末尾(默认) 2	       从头到尾，每隔一个取一个。用了2个冒号。

Export to Sheets

# set() 函数会创建一个集合。集合的一个关键特性是它只包含不重复的元素。
 集合（Set）是无序的。这意味着当你遍历一个集合时，元素的顺序是不固定的，Python 不保证会按照你当初写入的顺序输出。虽然程序会打印出 1, 2, 3, 4 这四个数字，但它们的排列顺序可能是 2413、4321 等任意组合。因此，“一定”是 1234 的说法是错误的。

# 问题: 列表可以作为字典的键。  正确答案: F (错误)
解析: 字典的键（key）必须是**不可变（immutable）**类型。
1. 可变类型（如列表 list、字典 dict）的值可以被修改，因此不能作为键。
2. 不可变类型（如整数 int、字符串 str、元组 tuple）的值不能被修改，可以作为键。
因为列表是可变的，所以它不能用作字典的键。

# 问题: 当作为条件表达式时，空值、空字符串、空列表、空元组、空字典、空集合、迭代对象以及任意形式的数字0都等价于False。 正确答案: F (错误)
解析: 这个描述中大部分是正确的，但在 Python 的“真值测试 (Truthiness)”规则中，“迭代对象” 这个说法不准确。
一个**迭代器**对象本身通常被认为是 True，只要它存在。例如，iter([]) 是一个空列表的迭代器，但 bool(iter([])) 的结果是 True。
语句中其他部分都是正确的：None、''、[]、()、{}、set() 以及各种 0（0, 0.0）在布尔上下文中都等同于 False。
因为包含了错误的描述（迭代对象），所以整个命题是错误的。

# 问题: 在循环中continue语句的作用是退出当前的循环。正确答案: F (错误)
解析: continue 的作用是跳过本次循环中余下的代码，直接进入下一次循环。而 break 才是退出整个循环。

# 问题: 不管是单层循环还是多层循环，只要执行到break语句，所有循环立即结束。正确答案: F (错误)
解析: break 语句只会跳出它所在的最内层的循环。

# 问题: 执行如下语句，程序陷入死循环状态。 while True: print("我要学python") 正确答案: T (正确)
解析: while True: 的条件永远为真，没有跳出循环的机制，所以是典型的无限循环（死循环）。



# int（）和 eval（）
我们可以把 `int()` 和 `eval()` 分别想象成两种不同的工具：

  * `int()` 是一个**专门的扳手**，它的唯一工作就是把看起来像整数的东西拧成真正的整数。
  * `eval()` 是一个**功能强大的、但没有安全防护的机器人**，你给它任何指令，它都会尝试去执行。

下面我们从几个方面来具体解释它们的区别：

-----

### 1\. 核心功能 (Core Function)

  * **`int()`: 类型转换器 (Type Converter)**
    它的唯一目的就是将一个字符串或数字**转换**成一个整数。它会按照整数的规则来解析输入，如果输入不符合整数的格式，它就会报错。

  * **`eval()`: 代码执行器 (Code Executor)**
    它的核心功能是**执行**。它会把传入的字符串当作一段有效的 Python **代码**来解析和运行，并返回代码执行后的结果。

-----

### 2\. 处理的内容 (What They Process)

  * **`int()` 只能处理数字字符串:**

    ```python
    int("123")         # 正确 -> 输出 123
    int("-45")         # 正确 -> 输出 -45
    int("   100   ")   # 正确，会自动处理前后空格 -> 输出 100

    # 以下都会报错
    int("10 + 5")      # 错误! 包含运算符，不是纯数字
    int("ten")         # 错误! 不是数字
    int("a = 5")       # 错误! 是代码语句
    ```

  * **`eval()` 可以处理任何有效的 Python 表达式:**

    ```python
    eval("123")        # 正确 -> 输出 123 (这是它和int()功能重叠的地方)
    eval("10 + 5")     # 正确 -> 输出 15 (因为它执行了加法运算)

    x = 10
    eval("x * 2")      # 正确 -> 输出 20 (它可以访问当前作用域的变量)

    eval("[1, 2, 3]")  # 正确 -> 输出列表 [1, 2, 3] (它能创建数据结构)
    eval("len('hello')") # 正确 -> 输出 5 (它能调用函数)
    ```

-----

### 3\. 安全性 (Security) - 这是最重要的区别！

  * **`int()`: 安全**
    因为它只接受数字格式的字符串，所以它是完全安全的。用户输入 `10+5` 或恶意代码，`int()` 只会抛出一个 `ValueError` 异常，不会对你的程序造成任何伤害。

  * **`eval()`: 极度危险**
    因为它会执行任何传给它的代码，所以如果将用户输入直接交给 `eval()`，就相当于给了用户在你电脑上执行任意代码的权限。这是一个巨大的安全漏洞。

    **危险示例 (切勿在真实项目中使用！):**
    假设你有一个程序，让用户输入内容，然后你用 `eval()` 来处理它。

    ```python
    user_input = input("请输入内容: ")
    result = eval(user_input)
    print(result)
    ```

    如果一个普通用户输入 `10+5`，一切正常。
    但如果一个恶意用户输入了以下内容：
    `__import__('os').system('rm -rf /')`  \# 在 Linux/macOS 上会尝试删除整个硬盘
    `__import__('os').system('dir')`      \# 在 Windows 上会列出当前目录的文件

    `eval()` 会毫不犹豫地执行这些命令，可能导致文件被删除、系统信息泄露等灾难性后果。

-----

### 核心区别总结

| 特性 | `int()` | `eval()` |
| :--- | :--- | :--- |
| **核心功能** | **类型转换** | **代码执行** |
| **处理内容** | 纯数字字符串 | 任何有效的Python表达式 |
| **安全性** | **安全** | **极度危险** |
| **使用场景** | 将用户输入转换为整数 | 极少数需要动态执行代码的特殊场景，且**绝不能**用于处理外部输入 |

### 结论与建议

**永远记住：当你想把用户输入的内容变成一个数字时，请务必使用 `int()` 或 `float()`。**

在 99.99% 的情况下，你都不需要，也**不应该**使用 `eval()`。在学习和工作中，养成避免使用 `eval()` 的习惯是一个非常好的安全实践。



# 问题: 当输入是：45,8 时，下面程序的输出结果是37。正确答案: T (正确)
解析:
input().split(',') 将输入 "45,8" 分割成 a='45' 和 b='8'。

b=int(b) 将 '8' 转换成整数 8。

关键在于 c=int(a,b)，它等价于 c=int('45', 8)。这是Python int() 函数的一个高级用法，表示将8进制的字符串 '45' 转换为10进制的整数。

计算：(4 * 8¹) + (5 * 8⁰) = 32 + 5 = 37。



