```python
print("这是数字输出格式{:5d}".format(123)) 
```
1. "这是数字输出格式{:5d}" 是一个包含格式化占位符的字符串：{:5d} 是一个格式化指令，其中：

: 表示开始格式规范

5 指定总宽度为5个字符

d 表示将值格式化为十进制整数

2. .format() 方法
.format(123) 将数字123插入到字符串的占位符中：
数字123被格式化为整数
由于指定了宽度为5，而123只有3位数字，所以会在左侧添加空格以达到5字符宽度


# Python 切片（slice）语法的关键点。

1. 完整的切片语法
Python 切片最完整的形式是 [start:stop:step]，它由两个冒号分隔开三个部分：

start: 起始索引（包含该位置）。

stop: 结束索引（不包含该位置）。

step: 步长（每次跳跃的距离）。

2. 语法的简写与默认值
为了方便使用，Python 允许你省略其中的任何部分，此时会使用默认值：

如果省略 start，它默认为 0（从头开始）。

如果省略 stop，它默认为列表的末尾。

如果省略 step，它默认为 1（一个挨一个地取，不跳跃）。

举几个例子来对比：

切片语法	start	  stop	     step	          解释
lst[0:100]	0	     100	    1（默认） 从索引0到100，步长为1。只用了1个冒号。 
lst[:5]	    0（默认）  5	     1(默认)	    从头到索引5之前。只用了1个冒号。
lst[2:]	    2	    末尾(默认)	  1(默认)	     从索引2到末尾。只用了1个冒号。
lst[::2]	0 (默认)   末尾(默认) 2	       从头到尾，每隔一个取一个。用了2个冒号。

Export to Sheets

# set() 函数会创建一个集合。集合的一个关键特性是它只包含不重复的元素。
 集合（Set）是无序的。这意味着当你遍历一个集合时，元素的顺序是不固定的，Python 不保证会按照你当初写入的顺序输出。虽然程序会打印出 1, 2, 3, 4 这四个数字，但它们的排列顺序可能是 2413、4321 等任意组合。因此，“一定”是 1234 的说法是错误的。

# 问题: 列表可以作为字典的键。  正确答案: F (错误)
解析: 字典的键（key）必须是**不可变（immutable）**类型。
1. 可变类型（如列表 list、字典 dict）的值可以被修改，因此不能作为键。
2. 不可变类型（如整数 int、字符串 str、元组 tuple）的值不能被修改，可以作为键。
因为列表是可变的，所以它不能用作字典的键。

# 问题: 当作为条件表达式时，空值、空字符串、空列表、空元组、空字典、空集合、迭代对象以及任意形式的数字0都等价于False。 正确答案: F (错误)
解析: 这个描述中大部分是正确的，但在 Python 的“真值测试 (Truthiness)”规则中，“迭代对象” 这个说法不准确。
一个**迭代器**对象本身通常被认为是 True，只要它存在。例如，iter([]) 是一个空列表的迭代器，但 bool(iter([])) 的结果是 True。
语句中其他部分都是正确的：None、''、[]、()、{}、set() 以及各种 0（0, 0.0）在布尔上下文中都等同于 False。
因为包含了错误的描述（迭代对象），所以整个命题是错误的。

# 问题: 在循环中continue语句的作用是退出当前的循环。正确答案: F (错误)
解析: continue 的作用是跳过本次循环中余下的代码，直接进入下一次循环。而 break 才是退出整个循环。

