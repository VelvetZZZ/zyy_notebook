# 🌳 树状结构数据 (Tree-Structured Data) 学习笔记

树状结构是一种非线性数据结构，由根节点和子节点（分支）组成。学习递归 (Recursion) 的主要原因是为了处理这种天然具有层次结构的数据。

---

## I. 列表 (函数式) 表示法

在 CS 61A 中，树被抽象地表示为一个 Python 列表，约定格式为：
**`[根节点标签, 子树1, 子树2, ...]`**

### 1. 构造函数 (Constructor)

| 函数 | 代码 | 作用 |
| :--- | :--- | :--- |
| `tree` | `def tree(label, branches=[]):` | 创建一棵树。第一个元素是标签，后续元素是子树列表。 |
| - | `return [label] + list(branches)` | 返回遵循约定的列表结构。 |

### 2. 选择器 (Selectors)

选择器用于提取树（列表 `t`）中的特定部分。

| 函数 | 代码 | 作用 |
| :--- | :--- | :--- |
| `label` | `def label(t):` | 返回根节点的值。 |
| - | `return t[0]` | 返回列表的第一个元素。 |
| `branches` | `def branches(t):` | 返回一个包含所有子树的列表。 |
| - | `return t[1:]` | 返回列表中索引 1 之后的所有元素（子树列表）。 |

### 3. 条件判断

| 函数 | 代码 | 作用 |
| :--- | :--- | :--- |
| `is_leaf` | `def is_leaf(t):` | 检查树是否是叶子节点（即没有子树）。 |
| - | `return not branches(t)` | 如果 `branches(t)` 返回空列表 `[]`，则结果为 `True`。 |

---

## II. 类 (面向对象) 表示法

使用 Python 类 `Tree` 来封装树的属性（数据）和方法（操作），提供更清晰和健壮的结构。

### 1. 类定义与初始化

```python
class Tree:
    def __init__(self, label, branches=[]):
        # 属性：存储根节点的值
        self.label = label
        # 属性：存储子树的列表
        self.branches = list(branches)
```

### 2. 方法 (Method)
```python
def is_leaf(self):
        # 方法：检查是否为叶子节点
        return not self.branches
```

## III. 核心知识点：递归与树结构
递归是处理树状数据结构最自然、最优雅的方式。
- *树的递归定义*： 任何一棵树都是由一个根节点和若干个子树构成，而每个子树本身又是一棵完整的树。

递归与树的匹配： 对整个树进行操作（如求和、遍历）时，只需要遵循两个步骤：

    1. 处理根节点（非递归部分）。
    2. 对每个子树进行相同的操作（递归调用）。
因此，学习递归是理解和操作这种层次结构数据（如表达式、文件系统、HTML/XML 结构等）的主要原因。