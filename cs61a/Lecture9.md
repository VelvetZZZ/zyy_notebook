递归函数

这页PPT介绍的是Luhn算法，该算法用于验证信用卡号码的有效性。通过该算法可以检测信用卡号码是否符合一定的校验规则。

Luhn算法的步骤：
	1.	从最右侧的数字开始（这是校验数字），向左移动，对每个第二个数字进行乘2的操作。如果乘积大于9（例如7*2=14），则将该乘积的各位数相加（例如14 → 1+4=5）。这样做的目的是避免数值过大的情况，并且简化为每个数字的单个位数。
	2.	计算所有数字的和，并检查该和是否能被10整除。如果和是10的倍数，则表示该信用卡号是有效的。

示例：

在PPT中的例子中，信用卡号是1 3 8 7 4 3 2，按照Luhn算法的规则处理如下：
	•	步骤1：从右向左遍历：
	•	第2个数字：2 → 乘以2后为4。
	•	第4个数字：7 → 乘以2后为14，1+4=5。
	•	第6个数字：3 → 乘以2后为6。
	•	第8个数字：8 → 乘以2后为16，1+6=7。
这样，计算得到的数字序列是：
1, 3, 8, 7, 4, 3, 2 → 1, 3, 8, 5, 4, 3, 7.
	•	步骤2：将所有数字相加，得出总和为：
1 + 3 + 8 + 5 + 4 + 3 + 7 = 30。

最后，Luhn算法要求计算结果为10的倍数。在这个例子中，30不是10的倍数，因此该信用卡号无效。

与Mutual Recursion（互递归）的关系：
	•	Mutual Recursion是指两个或多个函数相互调用的递归。对于Luhn算法的应用，可以通过递归的方式来实现对信用卡号每一位的计算，而递归函数之间的调用就是典型的互递归。举个例子：
	•	一个递归函数负责从右到左遍历信用卡号中的数字，并进行乘2以及求和操作。
	•	另一个递归函数负责计算每一位数字的和，判断和是否为10的倍数。

通过这种递归结构，我们可以使用Python中的递归函数来简化Luhn算法的实现，同时帮助学生理解如何通过递归和互递归的思想来实现复杂的算法逻辑。

代码实现（示例）：

# 递归实现Luhn算法验证
def luhn_algorithm(card_number, index=-1, total_sum=0):
    if abs(index) > len(card_number):
        # 结束递归，返回总和
        return total_sum % 10 == 0
    
    digit = int(card_number[index])
    # 每隔一个数字乘以2
    if (len(card_number) + index) % 2 == 0:
        digit *= 2
        if digit > 9:
            digit = digit - 9  # 或者直接计算个位数
    total_sum += digit
    # 递归调用
    return luhn_algorithm(card_number, index-1, total_sum)

# 测试
card_number = "1387432"
if luhn_algorithm(card_number):
    print("有效的信用卡号")
else:
    print("无效的信用卡号")

总结：

通过Luhn算法的实现，我们可以帮助学生理解如何用递归思想解决实际问题。在此过程中，学生不仅能学会如何实现Luhn算法，还能通过实现递归和互递归进一步提升Python编程能力，掌握递归调用的技巧。




---

### **通俗易懂版：递归与迭代的转换**

#### **什么是递归和迭代？**
- **递归（自己调用自己）**  
  > 想象你要整理一叠衣服：  
  > 1. 如果只剩一件衣服，直接叠好。  
  > 2. 如果有更多衣服，先叠最上面一件，剩下的交给“自己”继续叠。  
  > 这就是递归——把大问题拆成小问题，直到无法再拆解。

- **迭代（循环重复做一件事）**  
  > 就像洗衣服时，你一直重复“放入洗衣机→烘干→叠衣服”，直到所有衣服洗完。  
  > 迭代通过循环一步步完成任务，不需要调用自己。

---

#### **为什么要转换？**
- **递归的问题**：如果任务太大（比如叠1000件衣服），可能会累到崩溃（Python默认递归深度约1000层）。  
- **迭代的优势**：可以处理更大的任务，效率更高，不会“累倒”。

---

#### **怎么把递归变成迭代？**
**核心思想**：**把递归中“隐形的记忆”变成“显式的变量”**  
比如，递归时计算数字各位之和：  
- 递归版本会记住“当前数字的最后一位”和“剩下的数字”，然后交给下一个自己。  
- 迭代版本需要自己用变量记录这些信息。

---

#### **举个例子：计算数字各位之和**
**任务**：计算`123`的各位之和：`1 + 2 + 3 = 6`。

##### **1. 递归版（自己调用自己）**
```python
def sum_digits(n):
    if n < 10:       # 如果是个位数（比如3），直接返回
        return n
    else:
        all_but_last = n // 10   # 去掉最后一位（123 → 12）
        last = n % 10            # 取最后一位（123 → 3）
        return sum_digits(all_but_last) + last  # 继续处理剩下的数字，并累加最后一位
```
**递归过程**：  
`sum_digits(123)` → `sum_digits(12) + 3` → `sum_digits(1) + 2 + 3` → `1 + 2 + 3 = 6`

---

##### **2. 迭代版（用循环代替自己调用）**
**关键步骤**：  
- 用变量`total`记录累加结果。  
- 用循环不断处理剩下的数字，直到变成个位数。

```python
def sum_digits_iterative(n):
    total = 0           # 初始化累加器
    while n >= 10:      # 只要不是个位数就继续循环
        last = n % 10   # 取最后一位（123 → 3）
        total += last   # 累加到结果中（total = 0+3=3）
        n = n // 10     # 去掉最后一位（123 → 12）
    return total + n    # 最后加上剩下的个位数（3 + 1+2=6）
```
**迭代过程**：  
1. 初始：`n=123`, `total=0`  
2. 第一次循环：`last=3` → `total=3`，`n=12`  
3. 第二次循环：`last=2` → `total=5`，`n=1`  
4. 退出循环，返回`5 + 1 = 6`

---

#### **转换的万能口诀**
1. **找到递归的“记忆”**：递归每次调用时保存了什么信息？（比如剩下的数字、累加的值）  
2. **用变量代替记忆**：用循环变量（如`n`）和累加器（如`total`）保存这些信息。  
3. **循环代替递归调用**：把递归中的`return ...`变成更新变量并继续循环。  

---

#### **练习：试试把阶乘递归转迭代**
**递归版**  
```python
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)
```

**迭代版答案**  
```python
def factorial_iterative(n):
    result = 1
    while n > 1:
        result *= n
        n -= 1
    return result
```

---

#### **总结**
- **递归**：适合逻辑简单的问题，但别用它处理“太重的任务”。  
- **迭代**：适合需要高效处理大任务的情况。  
- **转换关键**：把递归中“隐形的步骤”变成循环中“显式的变量和条件”。  

**记住**：多写代码，多打印中间变量观察过程！比如在迭代版中加一句`print(f"当前n={n}, total={total}")`，就能看到每一步的变化。