# Programs as Data 程序就是数据

## A Scheme Expression is a Scheme List

> 在 Scheme 中：程序 = 表达式，而表达式本质上就是列表（list）

### Scheme 程序由两类表达式组成

Scheme 程序中的表达式（expression）有两类：

#### 1）Primitive expressions（基本表达式）
例子
```scheme
2
3.3
true
+
quotient
```
基本表达式的特点：
	•	不是组合式，直接表示一个值或名称
	•	求值方式很简单：
	•	字面量 → 自己
	•	名字 → 在环境中找它的绑定

#### 2）Combinations（组合式）
也就是用 括号 + 列表结构 写成的函数调用（procedure call）或特殊形式（special form）：
```scheme
(quotient 10 2)
(not true)
(+ 2 3)
```
#### 这类表达式本质上都是：
一个 list，car 是 operator，cdr 是 operand 列表

一个表达式 ----> 一个列表结构

表达式结构：Operator 与 Operand

在 Scheme/Lisp 语言中，所有的函数调用或特殊形式都采用**前缀表示法**（Prefix Notation），并统一使用**列表结构**来表示：

* **基本结构：** `(操作符 操作数1 操作数2 ...)`

#### 术语定义：

| 术语 (英文) | 中文 | 含义 | 对应列表结构 |
| :--- | :--- | :--- | :--- |
| **Operator** | **操作符 / 过程** | 列表中第一个元素，表示要执行的**动作**或**函数**。 | `car` |
| **Operand** | **操作数 / 运算元** | 列表中剩余的元素，表示操作符作用的**数据**或**参数**。 | `cdr` 列表 |

**示例：** `(+ 2 3)`
* `Operator` 是 `+` (加法函数)。
* `Operands` 是 `2` 和 `3` (被加数)。

### 组合式 = 列表

> Scheme 的列表数据结构（cons 链表）可以直接表示代码中的组合式。

#### 看看下面的表达式：

(list 'quotient 10 2)
求值后得到：
(quotient 10 2)
它不是执行 quotient，而只是把这个结构构造出来。

也就是说：

```text
list + quote = 构造“代码本身”
```
这就是 Scheme 的“代码即数据（code as data）”哲学。

### eval 可以执行这个表达式！

```scheme
(eval (list 'quotient 10 2))
```
#### 运行过程：
	1.	(list 'quotient 10 2) 生成列表结构 (quotient 10 2)
	2.	eval 读取这个列表，把它当作 Scheme 表达式执行
	3.	执行结果是：5

你会发现：

我们用 list 构造了一个程序，然后让 eval 执行了这个程序！

这让 Scheme 有了 **“元编程”** 的能力（program writes program）。

### 为什么这是解释器课程的关键？

因为下一步老师要教你写：

一个 Scheme 解释器（Meta-circular Evaluator）

要写解释器，你必须先理解：
	1.	Scheme 程序的结构是什么？（它是列表）
	2.	如何区分操作符与操作数？（car / cdr）
	3.	如何对表达式进行模式匹配？
	4.	“代码即数据（code as data）” 的思想

这是构建解释器的基础。

### 总结：
Scheme 表达式就是 Scheme 列表，因此 Scheme 语言可以用自己的数据结构来表示、操作、构造和执行代码。


## Scheme：quote 与 list

### 1. quote（'）是什么？

定义：quote 用来阻止求值，把后面的东西当作“数据”而不是“代码”。
其缩写形式是 '。

作用总结
	•	quote 返回“原样表达式”
	•	quote 让表达式变成数据
	•	quote 是 写解释器 和 元编程 的核心

“quote 保护代码，让它保持数据形态。”

### 2. list 是什么？

定义：list 用来构造一个 Scheme 列表（链表结构）。

#### 为什么重要？
因为在 Scheme 中：

一个组合式（函数调用）就是一个列表
比如：(quotient 10 2)
本质是：'(quotient 10 2)

你可以用 list 自己构造这个表达式：

(list 'quotient 10 2)
→ (quotient 10 2)

### 3. quote + list 的威力：代码即数据
示例：
(list '+ 1 2)
→ (+ 1 2)
现在它只是一个数据结构，还没执行。
你可以执行它：
(eval (list '+ 1 2))
→ 3
 **程序生成程序，再执行程序：元编程(Meta-programming)**


##  Quasiquotation in Scheme（拟引用）

### 核心概念：
 在 Scheme 中有两种方式可以对表达式进行引用(quote)：
 • 普通引用 (quote)：使用 ' 符号
例如：'(a b) 表示列表 (a b)，不会被求值。
 • 拟引用 (quasiquote)：使用 ` 符号
例如：`(a b) 也表示列表 (a b)，但其中的部分可以通过逗号 , 来“解引用”或求值。

### 区别举例

两者的区别体现在是否允许局部求值（unquote）：
```scheme
(define b 4)
```
普通引用：

```scheme
'(a ,(+ b 1))
=> (a (unquote (+ b 1)))  ; 逗号不会生效，整个表达式被当作数据处理
```
拟引用：

```scheme
`(a ,(+ b 1))
=> (a 5)  ; `b` 被求值，得到 5
```
📌 拟引用允许在静态结构中注入动态值。

### 应用场景：动态生成代码（代码写代码）

拟引用非常适合用于自动构造 Scheme 表达式，即 **程序生成程序**的场景：

```scheme
(define (make-add-procedure n)
  `(lambda (d) (+ d ,n)))
```
这是一个过程，它生成一个新的 lambda 表达式，其中 n 的值是通过 ,n 动态插入进去的。

调用示例：
```scheme
(make-add-procedure 10)
=> (lambda (d) (+ d 10))
```

(make-add-procedure 10) 最终生成的是一个新的函数 (lambda (d) (+ d 10))。
你可以再通过 eval 执行这个表达式，实现即时生成函数并调用的功能。


## 🚀 Scheme 高级抽象：`sum-while` 函数与元编程

## 一、 `sum-while` 函数概览

`sum-while` 函数是一个**高度抽象化的迭代求和模板**，它展示了 Lisp/Scheme 语言如何将通用的循环逻辑封装起来，让程序员只需关注“做什么”（逻辑），而无需关注“如何做”（实现细节）。

它的核心是使用**尾递归 (Tail Recursion)** 结构，确保在大范围迭代时不会导致栈溢出（TCO 优化）。

## 二、 函数参数与逻辑映射

`sum-while` 函数通过四个参数，将**迭代的逻辑**作为输入数据传入：

| 参数名称 | 作用 | 对应数学/编程概念 | 传入示例 |
| :--- | :--- | :--- | :--- |
| **`initial-x`** | 迭代器 $x$ 的起始值。 | 循环的起点。 | `1` 或 `2` |
| **`condition`** | 循环继续的条件表达式。 | 循环的结束条件。 | `' (< (* x x) 50)` |
| **`add-to-total`** | 每次迭代需要加到总和中的值。 | 求和项。 | `'x` 或 `'(* x x)` |
| **`update-x`** | 每次迭代 $x$ 的更新规则。 | 增量或迭代方式。 | `' (+ x 1)` 或 `' (+ x 2)` |

## 三、 核心机制与 Lisp 魅力

#### 1. 机制：尾递归的应用
函数内部使用一个内嵌的**尾递归**函数 `(f x total)` 来执行迭代。由于最后的调用是 `(f ...)` 本身，解释器可以进行**尾调用优化 (TCO)**，从而实现 O(1) 的栈空间占用，解决了传统递归的栈溢出问题。

#### 2. 优势：抽象与元编程 (Metaprogramming)
* **高度抽象：** 将迭代中所有可变的部分（起始、条件、求和项、增量）全部参数化，创建了一个通用的求和工具。
* **代码即数据：** 将 `'(* x x)` 这样的**代码表达式**作为参数传入函数中，由 `sum-while` 函数在内部进行操作和执行。这正是 **元编程** 思想的体现——程序在运行时动态地构造和执行代码。

---

## 四、 案例演示

使用 `sum-while` 解决我们讨论过的两个数学问题：

### 案例 1: 求平方小于 50 的数的和 (Result: 28)

* **问题：** 求 $N=1$ 开始，$N^2 < 50$ 的所有 $N$ 的和。
* **逻辑：** 从 1 开始，每次递增 1，加到总和中的是 $x$ 本身。

```scheme
;; 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28
(eval 
  (sum-while 1 
             '(< (* x x) 50) ; 终止条件：x^2 < 50
             'x              ; 求和项：加 x
             '(+ x 1)        ; 增量：x + 1
))
```
### 案例 2: 求小于 10 的偶数的平方和 (Result: 120)

* **问题**： 求 $N=2$ 开始，$N < 10$ 的所有偶数的平方和。
* **逻辑**： 从 2 开始，每次递增 2，加到总和中的是 $x^2$。Scheme;; 2^2 + 4^2 + 6^2 + 8^2 = 120
```scheme
(eval 
  (sum-while 2 
             '(< x 10)       ; 终止条件：x < 10
             '(* x x)        ; 求和项：加 x^2
             '(+ x 2)        ; 增量：x + 2
))
```


