# Scheme å­¦ä¹ ç¬”è®°ï¼šä½œç”¨åŸŸä¸è§£é‡Šå™¨ç»“æ„

---

## ğŸŒŸ ä»€ä¹ˆæ˜¯ä½œç”¨åŸŸï¼ˆScopeï¼‰ï¼Ÿ

ä½œç”¨åŸŸæ˜¯æŒ‡ï¼š**ç¨‹åºåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å¦‚ä½•æŸ¥æ‰¾å˜é‡ç»‘å®šï¼ˆå˜é‡çš„å€¼ï¼‰çš„ä½ç½®**ã€‚

---

## ğŸ“˜ 1. Lexical Scopeï¼ˆè¯æ³•ä½œç”¨åŸŸï¼‰

### âœ… å®šä¹‰ï¼š
å˜é‡åœ¨å‡½æ•° **å®šä¹‰æ—¶** æ‰€åœ¨çš„ç¯å¢ƒä¸­æŸ¥æ‰¾ã€‚è¿™ç§ä½œç”¨åŸŸè§„åˆ™åˆç§°ä¸º *static scope*ã€‚

### ğŸ§  æŸ¥æ‰¾è·¯å¾„ï¼š
1. å½“å‰å‡½æ•°ä½“ä¸­
2. å‡½æ•°å®šä¹‰æ—¶çš„ç¯å¢ƒ
3. ä¸€ç›´å‘ä¸Šç›´åˆ°å…¨å±€ç¯å¢ƒ

### ğŸ’¡ ç‰¹ç‚¹ï¼š
- ä»£ç ç»“æ„å†³å®šå˜é‡æŸ¥æ‰¾è·¯å¾„
- è¡Œä¸ºå¯é¢„æµ‹ã€æ˜“è°ƒè¯•
- ç°ä»£è¯­è¨€ï¼ˆSchemeã€Pythonã€JavaScriptã€Javaï¼‰æ™®éä½¿ç”¨

### âœ… ç¤ºä¾‹ï¼š

```scheme
(define x 5)
(define (foo) x)
(define (bar) (let ((x 10)) (foo)))
(bar) ; => 5
```

---

## ğŸ“• 2. Dynamic Scopeï¼ˆåŠ¨æ€ä½œç”¨åŸŸï¼‰

### âœ… å®šä¹‰ï¼š
å˜é‡åœ¨å‡½æ•° **è°ƒç”¨æ—¶** æ‰€åœ¨çš„ç¯å¢ƒä¸­æŸ¥æ‰¾ã€‚

### ğŸ§  æŸ¥æ‰¾è·¯å¾„ï¼š
1. å‡½æ•°è°ƒç”¨è€…çš„ç¯å¢ƒï¼ˆå³è°ƒç”¨æ—¶çš„ä¸Šä¸‹æ–‡ï¼‰
2. å†å¾€ä¸ŠæŸ¥è°ƒç”¨æ ˆä¸­çš„ä¸Šä¸€å±‚ç¯å¢ƒ

### ğŸ’¡ ç‰¹ç‚¹ï¼š
- è°ƒç”¨ä½ç½®å†³å®šæŸ¥æ‰¾è·¯å¾„
- è¡Œä¸ºä¸æ˜“é¢„æµ‹ï¼Œè°ƒè¯•å›°éš¾
- å°‘æ•°è¯­è¨€ä½¿ç”¨ï¼ˆæ—©æœŸ Lispã€Emacs Lispã€bashï¼‰

### âœ… ç¤ºä¾‹ï¼š

```scheme
(define f (lambda (x) (+ x y)))
(define g (lambda (x y) (f (+ x x))))
(g 3 7) ; => 13 ï¼ˆåœ¨ dynamic scope ä¸‹ï¼‰
```

---

## ğŸ§ª ä½œç”¨åŸŸè¡Œä¸ºå¯¹æ¯”ï¼š

| Scope ç±»å‹       | æŸ¥æ‰¾è§„åˆ™               | æ‰§è¡Œç»“æœ        |
|------------------|------------------------|------------------|
| Lexical Scope    | f çš„ parent æ˜¯å®šä¹‰ç¯å¢ƒ | âŒ æŠ¥é”™ï¼šæ‰¾ä¸åˆ° y |
| Dynamic Scope    | f çš„ parent æ˜¯è°ƒç”¨ç¯å¢ƒ g çš„ Frame | âœ… è¾“å‡º 13 |

---

## âš™ï¸ ä¸¤ç§ä½œç”¨åŸŸå¯ä»¥å…±å­˜å—ï¼Ÿ

- âœ… ç†è®ºä¸Šå¯ä»¥ï¼ˆå†™è§£é‡Šå™¨æ—¶æ§åˆ¶ Frame parentï¼‰
- âš ï¸ å®é™…ä¸Šä¸æ¨èå…±å­˜ï¼Œå®¹æ˜“äº§ç”Ÿå›°æƒ‘ä¸ bug
- Emacs Lisp æä¾›åˆ‡æ¢ dynamic/lexical çš„æœºåˆ¶

---

## ğŸ§± Python å®ç°ä½œç”¨åŸŸæŸ¥æ‰¾ï¼ˆäººå·¥æ¨¡æ‹Ÿï¼‰

```python
class Frame:
    def __init__(self, parent):
        self.bindings = {}
        self.parent = parent

    def define(self, name, val):
        self.bindings[name] = val

    def lookup(self, name):
        if name in self.bindings:
            return self.bindings[name]
        elif self.parent:
            return self.parent.lookup(name)
        else:
            raise NameError("Unbound variable: " + name)
```

---

## ğŸ§  è§£é‡Šå™¨ç»“æ„ï¼šEval ä¸ Apply

### ğŸ§© Evalï¼ˆevaluateï¼‰
- **ç†è§£è¡¨è¾¾å¼ï¼Œåˆ¤æ–­è¦åšä»€ä¹ˆ**
- Base Casesï¼š
  - æ•°å­— â†’ ç›´æ¥è¿”å›
  - å˜é‡ â†’ æŸ¥æ‰¾å…¶ç»‘å®šå€¼ï¼ˆsymbol lookupï¼‰
- Recursive Casesï¼š
  - å‡½æ•°è°ƒç”¨ â†’ eval æ“ä½œç¬¦ & å‚æ•° â†’ å† apply
  - ç‰¹æ®Šå½¢å¼ â†’ eval å„ä¸ªå­è¡¨è¾¾å¼

### ğŸ§© Applyï¼ˆapplicationï¼‰
- **æ‰§è¡Œè¿‡ç¨‹æˆ–å‡½æ•°ï¼Œåšäº‹æƒ…**
- Base Caseï¼š
  - å†…å»ºå‡½æ•°ï¼ˆå¦‚ `+`ã€`*`ï¼‰ â†’ ç›´æ¥è°ƒç”¨
- Recursive Caseï¼š
  - ç”¨æˆ·è‡ªå®šä¹‰å‡½æ•° â†’ åˆ›å»ºæ–°ç¯å¢ƒ â†’ eval å‡½æ•°ä½“

### ğŸ”„ å·¥ä½œæµç¨‹æ€»ç»“ï¼š

```scheme
(define square (lambda (x) (* x x)))
(square 5)
```

æ­¥éª¤ï¼š

1. `eval` è¯†åˆ« `(square 5)` æ˜¯å‡½æ•°è°ƒç”¨
2. `eval(square)` â†’ æ˜¯ä¸ªå‡½æ•°å¯¹è±¡
3. `eval(5)` â†’ å¾—åˆ° 5
4. `apply(square, 5)` â†’ åˆ›å»ºæ–° frameï¼Œx=5
5. `eval(* x x)` â†’ æœ€ç»ˆè®¡ç®—å‡º 25

---

## âœ… æ€»ç»“ï¼šEval vs Apply

| å‡½æ•° | ä½œç”¨ | æ¯”å–» |
|------|------|------|
| `eval` | åˆ¤æ–­åšä»€ä¹ˆ | â€œç†è§£ä»»åŠ¡â€ |
| `apply` | æ‰§è¡Œè¿‡ç¨‹ | â€œå®Œæˆä»»åŠ¡â€ |

è§£é‡Šå™¨æœ¬è´¨ä¸Šæ˜¯é€šè¿‡è¿™ä¸¤ä¸ªå‡½æ•°äº¤æ›¿è¿›è¡Œé€’å½’è°ƒç”¨æ¥è§£é‡Šä¸€æ•´é—¨è¯­è¨€ã€‚ç†è§£è¿™å¼ ç»“æ„å›¾ï¼Œä½ å°±ç†è§£äº† Scheme çš„è§£é‡Šå™¨æ ¸å¿ƒã€‚

---
