# 🧠 Parsing（语法解析）详解

## 一、Parsing 是什么？

> **Parsing（解析）** 的目标是：  
> 把**程序的文字（text）** 转换成计算机能理解的 **表达式结构（expression tree）**。

换句话说：  
👉 你写的代码是“字符串”，  
👉 解析器（parser）要把它变成一个能计算的结构。

---

## 二、总体流程

整个解析过程分为两个阶段：

```
Text → [Lexical Analysis] → Tokens → [Syntactic Analysis] → Expression
```

也就是两大步：  
1️⃣ **词法分析（Lexical Analysis）**  
2️⃣ **语法分析（Syntactic Analysis）**

---

## ✳️ 1. Lexical Analysis（词法分析）

> 把纯文本分解成一个个“词元”（tokens）。

例如：
```
(+ 1 (* 4 5.6))
```
会被拆分为：
```
'(', '+', '1', '(', '*', '4', '5.6', ')', ')'
```

这些小片段就叫 **tokens（词元）**。

### 🔍 它做什么？
- 按字符扫描源代码  
- 判断每个片段的类型（数字、符号、括号……）  
- 检查非法字符或拼写错误  

### ⚙️ 特点
- **Iterative process（迭代过程）**：一行一行地处理  
- **Checks malformed tokens（检测词法错误）**  
- **Determines token types（确定词元类型）**  
- **输出：合法 token 列表**

---

## ✳️ 2. Syntactic Analysis（语法分析）

> 把词法分析得到的 **tokens** 组合成一个 **有层次的表达式结构（Expression Tree）**。

输入 Tokens：
```
'(', '+', '1', '(', '*', '4', '5.6', ')', ')'
```

输出结构：
```
Pair('+', Pair(1, Pair(Pair('*', Pair(4, Pair(5.6, nil))), nil)))
```

对应可视化形式：
```
(+ 1 (* 4 5.6))
```

### 🪜 它做什么？
- 检查语法结构是否正确（如括号是否匹配）  
- 按规则“组装”成语法树（Abstract Syntax Tree, AST）  
- 返回结构化表达式（方便解释执行）  

### ⚙️ 特点
- **Tree-recursive process（树形递归过程）**  
- **Balances parentheses（平衡括号）**  
- **Returns tree structure（返回树结构）**

---

## 🧩 举例对比

| 阶段 | 输入 | 输出 | 示例 |
|------|------|------|------|
| 词法分析 | `"(* 4 5.6)"` | `['(', '*', '4', '5.6', ')']` | 拆分文本 |
| 语法分析 | token 列表 | 嵌套表达式（如 Pair 结构） | 构造结构 |

---

## 💡 类比理解

把 **Parser（解析器）** 想成一个“阅读理解”的过程：

- **词法分析** = 分词：识别“单词”  
- **语法分析** = 组句：识别“语法结构”

最终输出的是程序的**语义结构**（表达式树），而不是单纯的字符串。

---

## ✅ 总结一句话

> **Parsing = 从代码文本到结构化表达式的过程。**

| 阶段 | 主要功能 | 结果 |
|------|-----------|------|
| Lexical analysis | 拆分文本 → tokens | 检查合法性 |
| Syntactic analysis | tokens → 表达式结构 | 形成语法树 |

---

## 📘 课程关联

在 CS61A 中，这一部分属于解释器的核心内容之一。  
解析器（parser）是编程语言执行的第一步，它让计算机**理解我们写的代码结构**。

# 🧠 Syntactic Analysis（语法分析）详解

## 一、概念介绍

> **Syntactic Analysis（语法分析）** 用于识别表达式的层次结构（hierarchical structure）。  
> 它的目标是：从一串 **tokens（词元）** 中，**还原出完整的语法结构（表达式树）**。

换句话说：  
解析器（parser）负责回答“这些词元是如何组成一个合法的表达式”的问题。

---

## 二、解析总体思路

输入 token 列表：

```
'(', '+', 1, '(', '-', 23, ')', '(', '*', 4, 5.6, ')', ')'
```

输出对应的结构化表达式：

```
(+ 1 (- 23) (* 4 5.6))
```

也可以表示为：
```
Pair('+', Pair(1, Pair(Pair('-', Pair(23, nil)), Pair(Pair('*', Pair(4, Pair(5.6, nil))), nil))))
```

---

## 三、解析过程（由 `scheme_read` 实现）

> Each call to `scheme_read` consumes the input tokens for exactly one expression.

也就是说：  
每一次 `scheme_read` 调用，都**读取刚好组成一个完整表达式的 tokens**，然后返回结果。

---

## 四、递归解析的逻辑

语法分析器是一个**递归下降解析器（recursive descent parser）**，它的核心思想是：

| 情况 | 行为 |
|------|------|
| **Base case（基本情况）** | 如果 token 是数字或符号（symbol），直接返回该值。 |
| **Recursive case（递归情况）** | 如果 token 是 `'('`，说明是一个子表达式。<br>→ 递归调用 `scheme_read` 解析子表达式；<br>→ 一直读取直到匹配到对应的 `')'` 为止。 |

---

### 🪜 解析过程示例

输入 tokens：
```
['(', '+', 1, '(', '-', 23, ')', '(', '*', 4, 5.6, ')', ')']
```

解析流程：

1. 看到 `'('` → 开始新表达式  
2. 读取 `'+'` → 这是操作符  
3. 读取 `1` → 第一个参数  
4. 读取 `'('` → 嵌套结构，递归调用处理 `(- 23)`  
5. 返回结果后继续，读取下一组 `'('` → 递归解析 `(* 4 5.6)`  
6. 组合所有子结果 → 返回完整的表达式树

---

## 五、结构可视化

解析结果构成一棵树：

```
(+
   1
   (- 23)
   (* 4 5.6)
)
```

这棵树结构清晰地反映了表达式的层次与嵌套关系。

---

## 六、关键点总结

| 概念 | 含义 |
|------|------|
| **Lexical Analysis** | 把文本拆成 tokens |
| **Syntactic Analysis** | 按语法规则组合 tokens，形成树结构 |
| **Base Case** | 数字或符号：直接返回 |
| **Recursive Case** | 括号表达式：递归解析并组合 |
| **Result** | 树形表达式结构（AST） |

---

## 七、课程延伸

在 CS61A 的解释器部分：  
- `scheme_read` 就是执行“语法分析”的函数；  
- 它将 token 列表转为 Scheme 表达式树；  
- 每个子表达式由递归完成，最终形成完整的结构化语法树。

---

## ✅ 一句话总结

> **语法分析（Syntactic Analysis） = 递归地从 token 列表重建表达式树。**

每个括号都代表一次递归，  
每次递归返回一个完整的子表达式，  
最终组合成整个程序的语法结构。


