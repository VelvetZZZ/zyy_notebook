# 🧠 Scheme 中的 `cons`、pair 与列表结构  

---

## 🌱 1. 基础概念：`cons` 的作用

`cons` 是 Scheme 中最基础的构造函数，用于**构造一个 pair（对）**。

```scheme
(cons a b)
```

它创建一个包含两个部分的“盒子”结构：

```
+---+---+
| a | b |
+---+---+
```

- **car**：表示第一个槽（a）  
- **cdr**：表示第二个槽（b）

---

## 🧩 2. 列表的构成：由一连串 pair 组成

一个 Scheme 列表 `(1 2 3)` 实际上是多个 `cons` 嵌套构成的：

```scheme
(cons 1 (cons 2 (cons 3 nil)))
```

相当于：
```
+---+---+    +---+---+    +---+---+
| 1 | o----> | 2 | o----> | 3 | / |
+---+---+    +---+---+    +---+---+
```

- 最后一个 `cdr` 为 `nil`，表示列表的**结束**
- 整个结构是一个**链表（linked list）**

---

## 🧠 3. 当 `cdr` 不是列表时会发生什么？

### ⚠️ 1️⃣ `cdr` 不是 `nil` 或列表

如果 `b`（即第二个参数）不是 `nil` 或一个列表，结果就不是纯列表，而是一个普通的 **pair**。

```scheme
(cons 1 2)
```

输出：
```
(1 . 2)
```

- 这里的点号 `.` 表示一个 **一般的 pair**
- 结构图：

```
+---+---+
| 1 | 2 |
+---+---+
```

---

### ⚙️ 2️⃣ 嵌套的 pair 结构

```scheme
(cons (cons 1 2) 3)
```

输出：
```
((1 . 2) . 3)
```

结构图：

```
+---+---+
| o | 3 |
+-|-+---+
  |
  v
+---+---+
| 1 | 2 |
+---+---+
```

说明：
- `car` 部分本身又是一个 pair
- 这就是**嵌套的 pair 结构（nested pairs）**

---

## ✅ 4. 纯列表的条件

一个结构要成为真正的列表，必须满足：

> **每个 `cons` 的 `cdr` 都指向另一个列表或 `nil`。**

| 表达式 | 输出 | 是否为列表 | 说明 |
|:---------|:----------|:-----------|:-------------|
| `(cons 1 (cons 2 nil))` | `(1 2)` | ✅ 是 | 每个 cdr 都是列表 |
| `(cons 1 2)` | `(1 . 2)` | ❌ 否 | cdr 不是列表 |
| `(cons (cons 1 2) 3)` | `((1 . 2) . 3)` | ❌ 否 | cdr 是原子值 |
| `(cons (cons 1 2) (cons 3 nil))` | `((1 . 2) 3)` | ✅ 是 | 嵌套结构但仍为列表 |

---

## 🧾 5. `car` 与 `cdr` 操作

可以使用 `car` 和 `cdr` 访问 pair 的内容：

```scheme
(define x (cons 1 (cons 2 nil)))
(car x) ; 输出: 1
(cdr x) ; 输出: (2)
```

- **`car`** 取出第一个元素
- **`cdr`** 取出“剩下的列表”

---

##  6. 复杂嵌套结构举例

```scheme
(define x (cons 1 (cons 2 (cons 3 (cons 4 nil)))))
```

输出：
```
(1 2 3 4)
```

相当于 Python 中的嵌套结构：
```python
(1, (2, (3, (4, None))))
```

- 实际上就是一个 **链表结构**。
- 每个 `cons` 连接到下一个 `cons`，直到遇到 `nil`。

---

## 🧭 7. 显示形式（Scheme 的自动格式化）

```scheme
(1 2 3 4)
```

等价于：
```scheme
(cons 1 (cons 2 (cons 3 (cons 4 nil))))
```

Scheme 会**自动省略**括号与 `nil`，以简洁的形式显示完整的链表结构。

---

## 🔍 8. 核心理解总结

| 概念 | 说明 |
|:------|:------|
| **`cons`** | 创建一个 pair（a . b） |
| **pair** | 一个包含两个槽（car 与 cdr）的数据结构 |
| **list** | 一连串由 `cons` 链接、且 `cdr` 最终为 `nil` 的结构 |
| **非列表 pair** | 若 `cdr` 指向非列表，即为普通 pair |
| **嵌套 pair** | 若 `car` 或 `cdr` 含另一个 pair，形成嵌套结构 |

---

## 🧭 9. 思维导图记忆

```
cons
 ├── 基本作用：创建 (a . b)
 ├── 若 b 是列表 → 构成链表结构
 ├── 若 b 不是列表 → 一般 pair
 ├── 若嵌套 → 嵌套 pair
 └── 纯列表条件：所有 cdr → 列表 或 nil
```

---

## 🧩 10. 小结

- **`cons`** 是一切列表结构的基础。  
- **列表** 只是由特殊形态的 pair 构成的链表。  
- 若任何 `cdr` 不是 `nil` 或列表，结构就断裂为“嵌套 pair”。  
- 理解 `cons` 的语义，就能理解 Scheme 的一切复杂数据结构。



# 🧭 CS61A Scheme 学习笔记

> **课程背景**：  
> 本笔记基于 UC Berkeley 的 CS61A 课程（Structure and Interpretation of Computer Programs），  
> 使用的语言是 **Scheme**（Lisp 的一个方言）。

---

## 🧠 一、Scheme 与 Lisp 的关系

| 语言 | 诞生时间 | 特点 | 应用 |
|------|-----------|------|------|
| **Lisp** | 1958（John McCarthy） | 最早的函数式语言之一，强调“代码即数据” | AI、编译器、抽象计算 |
| **Scheme** | 1975（Sussman & Steele） | Lisp 的简化版，语法更干净，逻辑统一，支持词法作用域 | 教学与研究（MIT, Berkeley） |
| **Common Lisp** | 1980s | 工程化更强，语法更复杂 | 工业界、AI 项目 |

📘 **一句话总结**：
> Scheme 是 Lisp 的现代教学方言，语法更简洁、逻辑更纯粹。

---

## 🧩 二、Symbolic Programming（符号化编程）

在一般语言（如 Python）中：

```python
a = 1
b = 2
[a, b]   # -> [1, 2]
```

在 Scheme 中：

```scheme
(define a 1)
(define b 2)
(list a b)   ; => (1 2)
```

但如果我们想要得到符号本身 `(a b)`，而不是它们的值 `(1 2)`，  
就要用 **quotation（引用）**。

---

## ✨ 三、Quotation（引用）

```scheme
(list 'a 'b)   ; => (a b)
```

解释：
- `'a` 是 `(quote a)` 的简写；
- `quote` 表示「不要求值」，把表达式本身当作数据。

| 表达式 | 含义 | 结果 |
|----------|--------|--------|
| `(list a b)` | 变量求值后组成列表 | `(1 2)` |
| `(list 'a 'b)` | 引用符号本身 | `(a b)` |
| `(list 'a b)` | 混合：符号 + 值 | `(a 2)` |

---

## 💻 四、在 VS Code 中运行 Scheme

如果你使用 MIT Scheme 解释器：

- 当你点击 “Run Scheme” 时，文件会被“加载”；
- **不会自动打印最后一行结果**；
- 如果想看到输出，需要用：

```scheme
(display (list a b))
(newline)
```

解释：
- `(display ...)`：打印结果；
- `(newline)`：换行。

输出示例：
```
(1 2)
```

---

## ⚙️ 五、常见错误与修正

| 错误代码 | 问题原因 | 修正写法 |
|-----------|------------|------------|
| `(display((list a b)))` | 双括号，Scheme 以为 `(1 2)` 是函数 | `(display (list a b))` |
| `(display (a, b, c))` | Scheme 中 `,` 不是分隔符，而是 `unquote` | `(display '(a b c))` |
| 运行无输出 | 文件执行不自动打印结果 | 加 `(display ...)` |
| 运行时报 “object not applicable” | 尝试调用非函数对象 | 检查括号嵌套 |

---

## 🟩 六、注释写法

| 类型 | 语法 | 说明 |
|------|------|------|
| 单行注释 | `; 这是注释` | 从 `;` 到行尾都是注释 |
| 块注释 | `#| 多行注释 |#` | 可多行、可嵌套 |

示例：
```scheme
; 定义变量
(define a 1)

#|
(define b 2)
(display a)
|#
```

---

## 🧱 七、列表操作：`car` 与 `cdr`

假设我们有：
```scheme
'(a b c)
```

### 1️⃣ `car`
取列表第一个元素：
```scheme
(car '(a b c))   ; => a
```

### 2️⃣ `cdr`
取除第一个元素外的“剩余列表”：
```scheme
(cdr '(a b c))   ; => (b c)
```

### 3️⃣ 组合用法
```scheme
(cadr '(a b c))   ; 第二个元素 => b
(caddr '(a b c))  ; 第三个元素 => c
```

| 函数 | 等价形式 | 结果 |
|--------|--------------|--------|
| `car` | 第一个元素 | `a` |
| `cdr` | 剩下的元素 | `(b c)` |
| `cadr` | `(car (cdr ...))` | `b` |
| `caddr` | `(car (cdr (cdr ...)))` | `c` |

---

## 🚫 八、关于错误字幕 “cutter”

> 视频字幕里说的 “cutter” 实际上是 **“cdr”** 的听写错误。

原句应为：
> “The car of that is the symbol A, and the **cdr** of that is the list containing the symbols B and C.”

---

## 📦 九、总结：Scheme 编程核心思路

| 概念 | 含义 | 示例 |
|------|------|------|
| `define` | 定义变量或函数 | `(define a 1)` |
| `list` | 创建列表 | `(list 1 2 3)` |
| `quote` / `'` | 阻止求值 | `'a` 或 `'(1 2)` |
| `car` / `cdr` | 取列表元素 | `(car '(a b c))` |
| `display` | 打印输出 | `(display (list a b))` |
| `newline` | 换行 | `(newline)` |

---

## 💬 十、常用调试小技巧

- 想看 Scheme 文件运行结果？  
  → 用 `(display ...)` 输出。  
- 想在 REPL 测试？  
  → 输入 `(load "filename.scm")`。  
- 想临时屏蔽一段代码？  
  → 用 `#| ... |#` 包起来。

---

## 🧭 十一、学习路线建议

1. **掌握基础语法**（`define`, `if`, `lambda`, `list`, `car`, `cdr`）
2. **理解函数式思想**（函数是一等公民）
3. **学习递归与高阶函数**
4. **探索 SICP 内容**（构造解释器、宏、元编程）

---

✅ **一句话总结**
> Scheme 是一门思想极简但威力巨大的语言。  
> 理解 `quote`、`list`、`car`、`cdr`，你就已经踏入了 SICP 的核心世界。
