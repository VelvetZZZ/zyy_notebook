
# 🧠 CS61A：Scheme 表达式求值机制笔记（通俗解释）

> 来源：伯克利大学 CS61A《结构与解释计算机程序》

---

## ✳️ 什么是 Scheme 表达式求值？

在 Scheme 编程语言中，**每个表达式都要被“求值”**（也就是解释器会执行它，得到一个结果）。

解释器根据表达式的“形式”来判断怎么处理它们，主要分三类：

---

## 1️⃣ 情况一：变量名（Symbol）

**例子**：`x`

- Scheme 会去当前环境（一个存储变量的“表格”）里查找变量名对应的值。
- 类比：你在冰箱里找写了你名字的饭盒。

---

## 2️⃣ 情况二：字面量（Self-evaluating Expression）

**例子**：`3`、`"hello"`、`#t`

- 表达式本身就是值，不用进一步求值。
- 类比：看到数字“3”就知道它是数字 3，不用解释或查找。

---

## 3️⃣ 情况三：组合式（Combination）

**例子**：`(f x)`、`(define x 3)`、`(if #t 1 2)`

- 组合式是用括号包起来的列表。
- Scheme 会把第一个元素当作函数或关键字，其它元素当作参数来执行。

---

## 🧩 特殊形式（Special Forms）

有些组合式不是普通函数调用，它们叫**特殊形式**，必须由 Scheme 解释器特殊处理。

| 特殊形式 | 用法说明 |
|----------|----------|
| `(if <条件> <为真时结果> <为假时结果>)` | 条件表达式 |
| `(define <名字> <表达式>)` | 定义变量或函数 |
| `(lambda (<参数>) <函数体>)` | 匿名函数定义（相当于 Python 的 lambda） |

> ✅ 特殊形式通过“列表的第一个元素”来识别

---

## 🧮 普通函数调用（Call Expression）

不是特殊形式的组合式就当作函数调用处理。

**例子**：

```scheme
(+ 1 2)
(map square '(1 2 3))
(sqrt 9)
```

执行步骤：
1. 先求出第一个位置（函数）
2. 再求出参数
3. 执行函数调用

---

## 📌 示例代码讲解

```scheme
(define (demo s)
  (if (null? s)
      '(3)
      (cons (car s) (demo (cdr s)))))
```

逐行解释：

- 定义了一个函数 `demo`，输入参数为列表 `s`
- 如果 `s` 是空列表：返回 `'(3)`
- 否则：
  - 取出第一个元素 `car s`
  - 递归调用 `(demo (cdr s))`（处理剩下的元素）
  - 用 `cons` 拼成一个新列表

**结果作用**：把列表原样复制下来，并在末尾添加一个 3。

---

## ✅ 总结：Scheme 表达式求值流程

```
表达式 E →
    ├─ 是变量名？→ 去环境中查找
    ├─ 是字面量？→ 直接返回
    └─ 是列表？
        ├─ 是特殊形式？→ 特殊规则处理
        └─ 否 → 当作函数调用处理
```

---

## 🔍 小技巧：如何识别特殊形式？

看列表的第一个元素：
- 是 `if`、`define`、`lambda` 等？→ 特殊形式
- 否则就是普通函数调用



# Scheme 中的 `quote` 表达式


## 主题：Quotation（引用表达式）

### 关键点总结：

在 Scheme 中，`quote` 是一个**特殊形式**（special form），它的作用是：

> **告诉解释器不要去执行括号里的表达式，而是把它原样保留下来作为数据。**

---

## 🔍 举例说明

```scheme
(quote (+ 1 2))
```
这段代码 不会去做加法运算，而是直接变成一个 列表：

```scheme
(+ 1 2)
```
这个结果是一个三元素的列表：+、1、2，而不是值 3。

## ' 是 quote 的简写！
下面两种写法是完全等价的：
```scheme
(quote (1 2))    ; 标准写法
'(1 2)           ; 简写
```
## 为什么需要 quote？
在 Scheme 中，大多数东西看起来都像是函数调用，例如：(+ 1 2)
如果你不给它加 quote，它会被执行，返回结果 3。
但有时候你只是想要列表本身，比如 (1 2)，不是想执行它，这时候就得用 quote。

## 背后发生了什么？
当你写 '(...) 时，Scheme 的解析器（parser）会自动把它转换为：(quote (...))

💡 所以 'abc → (quote abc)
'(+ 1 2) → (quote (+ 1 2))