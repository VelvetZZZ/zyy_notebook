
# 🧠 CS61A：Scheme 表达式求值机制笔记（通俗解释）

> 来源：伯克利大学 CS61A《结构与解释计算机程序》

---

## ✳️ 什么是 Scheme 表达式求值？

在 Scheme 编程语言中，**每个表达式都要被“求值”**（也就是解释器会执行它，得到一个结果）。

解释器根据表达式的“形式”来判断怎么处理它们，主要分三类：

---

## 1️⃣ 情况一：变量名（Symbol）

**例子**：`x`

- Scheme 会去当前环境（一个存储变量的“表格”）里查找变量名对应的值。
- 类比：你在冰箱里找写了你名字的饭盒。

---

## 2️⃣ 情况二：字面量（Self-evaluating Expression）

**例子**：`3`、`"hello"`、`#t`

- 表达式本身就是值，不用进一步求值。
- 类比：看到数字“3”就知道它是数字 3，不用解释或查找。

---

## 3️⃣ 情况三：组合式（Combination）

**例子**：`(f x)`、`(define x 3)`、`(if #t 1 2)`

- 组合式是用括号包起来的列表。
- Scheme 会把第一个元素当作函数或关键字，其它元素当作参数来执行。

---

## 🧩 特殊形式（Special Forms）

有些组合式不是普通函数调用，它们叫**特殊形式**，必须由 Scheme 解释器特殊处理。

| 特殊形式 | 用法说明 |
|----------|----------|
| `(if <条件> <为真时结果> <为假时结果>)` | 条件表达式 |
| `(define <名字> <表达式>)` | 定义变量或函数 |
| `(lambda (<参数>) <函数体>)` | 匿名函数定义（相当于 Python 的 lambda） |

> ✅ 特殊形式通过“列表的第一个元素”来识别

---

## 🧮 普通函数调用（Call Expression）

不是特殊形式的组合式就当作函数调用处理。

**例子**：

```scheme
(+ 1 2)
(map square '(1 2 3))
(sqrt 9)
```

执行步骤：
1. 先求出第一个位置（函数）
2. 再求出参数
3. 执行函数调用

---

## 📌 示例代码讲解

```scheme
(define (demo s)
  (if (null? s)
      '(3)
      (cons (car s) (demo (cdr s)))))
```

逐行解释：

- 定义了一个函数 `demo`，输入参数为列表 `s`
- 如果 `s` 是空列表：返回 `'(3)`
- 否则：
  - 取出第一个元素 `car s`
  - 递归调用 `(demo (cdr s))`（处理剩下的元素）
  - 用 `cons` 拼成一个新列表

**结果作用**：把列表原样复制下来，并在末尾添加一个 3。

---

## ✅ 总结：Scheme 表达式求值流程

```
表达式 E →
    ├─ 是变量名？→ 去环境中查找
    ├─ 是字面量？→ 直接返回
    └─ 是列表？
        ├─ 是特殊形式？→ 特殊规则处理
        └─ 否 → 当作函数调用处理
```

---

## 🔍 小技巧：如何识别特殊形式？

看列表的第一个元素：
- 是 `if`、`define`、`lambda` 等？→ 特殊形式
- 否则就是普通函数调用



# Scheme 中的 `quote` 表达式


## 主题：Quotation（引用表达式）

### 关键点总结：

在 Scheme 中，`quote` 是一个**特殊形式**（special form），它的作用是：

> **告诉解释器不要去执行括号里的表达式，而是把它原样保留下来作为数据。**

---

## 🔍 举例说明

```scheme
(quote (+ 1 2))
```
这段代码 不会去做加法运算，而是直接变成一个 列表：

```scheme
(+ 1 2)
```
这个结果是一个三元素的列表：+、1、2，而不是值 3。

## ' 是 quote 的简写！
下面两种写法是完全等价的：
```scheme
(quote (1 2))    ; 标准写法
'(1 2)           ; 简写
```
## 为什么需要 quote？
在 Scheme 中，大多数东西看起来都像是函数调用，例如：(+ 1 2)
如果你不给它加 quote，它会被执行，返回结果 3。
但有时候你只是想要列表本身，比如 (1 2)，不是想执行它，这时候就得用 quote。

## 背后发生了什么？
当你写 '(...) 时，Scheme 的解析器（parser）会自动把它转换为：(quote (...))

💡 所以 'abc → (quote abc)
'(+ 1 2) → (quote (+ 1 2))


# Scheme 中的 Logical Special Forms（逻辑特殊形式）



## 📌 什么是 “逻辑特殊形式”？

逻辑特殊形式（Logical Special Forms）是一些看起来像函数调用，但实际上执行方式**不同于普通函数调用**的 Scheme 表达式。

这些形式的特点是：

> **只会执行部分子表达式（sub-expressions）**，不会全部都执行！

---

## 🧾 常见逻辑特殊形式汇总

| 特殊形式 | 结构 | 含义 |
|----------|------|------|
| `if`     | `(if <判断> <为真时执行> <为假时执行>)` | 如果判断成立，就只执行真分支 |
| `and`    | `(and e1 e2 ... en)` | 如果前面的值是 `#f`，后面的不会继续执行（短路） |
| `or`     | `(or e1 e2 ... en)`  | 如果前面的值是 `#t`，后面的不会继续执行（短路） |
| `cond`   | `(cond (p1 e1) (p2 e2) ... (else en))` | 类似多个 `if` 的组合结构 |

---

## ✅ `if` 是怎么运行的？

Scheme 中的 `if` 表达式不直接求值所有参数，而是这样工作的：

1. **先执行判断部分**（`<predicate>`）
2. 判断成立（非 `#f`）→ 执行 `<consequent>`
3. 判断不成立（是 `#f`）→ 执行 `<alternative>`

> ⚠️ 注意：只会执行 `<consequent>` 或 `<alternative>` 中的一个！

### 也就是说：
```scheme
(if (> 3 2) 'yes 'no)
```
结果是：yes

### 重点解释：cond 表达式
cond 是 Scheme 里的多重条件语句，相当于 Python 中的 if-elif-else 结构。

 语法：
 (cond
  (<判断1> <结果1>)
  (<判断2> <结果2>)
  ...
  (else <默认结果>)
)

	•	每一行是一个分支：(条件 表达式)
	•	Scheme 会从上到下判断每个条件
	•	遇到第一个为真的条件，就执行对应的表达式
	•	不会再继续看下面的分支
	•	如果没有任何条件为真，且有 else 分支，就执行 else

###  总结要点
	•	if 是二选一逻辑：只执行一边
	•	and / or 是逻辑连接，具有“短路”特性
	•	cond 是多分支判断语句，遇真即停
	•	所有这些都不会像函数一样“全都执行”，而是根据条件“挑着执行”


# Lambda Expressions
见另一笔记

