# Python 中的递归与迭代 —— 学习笔记

> 更新时间：2025-10-26

---

## 📘 背景知识：计算阶乘

在计算机语言中，阶乘（factorial）是一个典型的例子来对比 **递归** 与 **迭代** 两种编程思维。

目标：计算 `k * n!`

---

## 🧮 示例代码对比

### 🟩 递归版本

```python
def factorial(n, k):
    if n == 0:
        return k
    else:
        return factorial(n - 1, k * n)
```

- 每次调用函数，都会创建新的函数栈帧（frame）。
- 空间复杂度：Θ(n)
- 时间复杂度：Θ(n)

---

### 🟦 迭代版本

```python
def factorial(n, k):
    while n > 0:
        n, k = n - 1, k * n
    return k
```

- 不创建新的函数栈帧，只用循环。
- 空间复杂度：Θ(1)
- 时间复杂度：Θ(n)

---

## ⏱ 渐进时间/空间复杂度

| 复杂度         | 表达       | 举例说明（n=10, 100, 1000） | 增长速度     | 说明/常见场景 |
|----------------|------------|-----------------------------|--------------|----------------|
| **常数时间**    | Θ(1)       | 永远只做固定几步             | 🚀 最快        | 数组取值、哈希查找 |
| **对数时间**    | Θ(log n)   | 4, 7, 10                    | 🟢 很快        | 二分查找、平衡树 |
| **线性时间**    | Θ(n)       | 10, 100, 1000               | ⚖️ 可接受      | 遍历列表、统计和 |
| **线性对数**    | Θ(n log n) | 33, 664, 9966               | ⏳ 快速增长    | 快速排序、归并排序 |
| **平方时间**    | Θ(n²)      | 100, 10,000, 1,000,000      | 🐢 非常慢      | 嵌套循环，冒泡排序 |
| **指数时间**    | Θ(2ⁿ)      | 1024, 1e30, …               | ❌ 灾难性增长   | 穷举递归，状态爆炸 |
| **阶乘时间**    | Θ(n!)      | 3628800, …                 | ❌❌❌ 超灾难    | NP难问题、全排列 |

---

## 🤔 为什么递归空间更大？

- 每次递归调用都必须 **暂存现场（压栈）**。
- 栈空间 = 调用深度 = **Θ(n)**
- 迭代则是复用固定变量，不用函数调用。

---

## 🧠 编程风格思维对比

| 维度     | 递归                   | 迭代               |
|----------|------------------------|--------------------|
| 抽象程度 | 高，更贴近数学定义     | 程序控制更明确     |
| 空间使用 | 多（调用栈）           | 少（常量空间）     |
| 可读性   | 更优雅，适合表达递归结构 | 更直接，适合工程实践 |
| 性能     | 栈开销大，慢            | 快速               |

---

## ✅ 总结一句话：

> 渐进复杂度描述的是规模变大时的**增长趋势**，递归在表达力上优雅，但在效率和空间上不如迭代适合大规模问题。

---


# 时间复杂度与空间复杂度学习笔记

## 一、什么是时间复杂度？

时间复杂度（Time Complexity）是衡量算法执行所需时间随输入规模增长而增长的量级。我们使用大 O 符号来描述它的上界。例如：

- O(1)：常数时间，执行时间不随输入增长。
- O(n)：线性时间，执行时间随着输入 `n` 增长。
- O(n^2)：平方时间，常见于双重循环。
- O(log n)：对数时间，常见于二分查找。

这不是精确时间，而是估计增长趋势的“渐进复杂度”。

## 二、什么是空间复杂度？

空间复杂度（Space Complexity）衡量的是算法在运行过程中使用的额外内存空间。它也使用大 O 表示：

- O(1)：使用固定空间。
- O(n)：需要随输入增长的线性空间（例如存储数组）。

## 三、PPT 示例分析（阶乘计算）

```python
def factorial(n, k):
    if n == 0:
        return k
    else:
        return factorial(n - 1, k * n)
```

```python
def factorial(n, k):
    while n > 0:
        n, k = n - 1, k * n
    return k
```

| 实现方式 | 时间复杂度 | 空间复杂度 |
|----------|--------------|--------------|
| 递归版本 | Θ(n)        | Θ(n)        |
| 迭代版本 | Θ(n)        | Θ(1)        |

### 为什么递归空间复杂度更高？

因为每一次函数调用都要**开辟一个新的调用帧**（call stack），直到返回。比如 `factorial(5, 1)` 会调用 5 次函数，内存中就有 5 个栈帧未释放。而迭代用循环实现，没有额外开栈帧，只复用固定变量，因此空间开销低。

## 四、递归 vs 迭代：编程思维差异

- **递归思维**：更符合数学定义，表达清晰，但可能栈溢出（空间占用大）。适合描述自然递归结构的问题，如树、图。
- **迭代思维**：更底层、更高效，更容易控制资源使用。

## 五、渐进复杂度图示参考

（此处可配图：常见复杂度函数增长图，如 O(1), O(log n), O(n), O(n log n), O(n^2)）

## 六、结论

- **时间复杂度**衡量的是运行时间随输入增长的快慢；
- **空间复杂度**衡量的是内存占用随输入增长的快慢；
- 递归更直观但空间开销大，迭代更高效但表达繁琐；
- 编程中需根据实际场景权衡使用递归或迭代。
